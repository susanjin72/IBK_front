{"version":3,"file":"columnUtils.js","sourceRoot":"","sources":["../../src/utils/columnUtils.ts"],"names":[],"mappings":"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","sourcesContent":["import { Column, CalculatedColumn, ColumnMetrics, CellContentRenderer } from '../common/types';\nimport { getScrollbarSize } from './domUtils';\n\ninterface Metrics<R> {\n  columns: Column<R>[];\n  columnWidths: Map<keyof R, number>;\n  minColumnWidth: number;\n  viewportWidth: number;\n  defaultCellContentRenderer: CellContentRenderer<R>;\n}\n\nexport function getColumnMetrics<R>(metrics: Metrics<R>): ColumnMetrics<R> {\n  let left = 0;\n  let totalWidth = 0;\n  let allocatedWidths = 0;\n  let unassignedColumnsCount = 0;\n  let lastFrozenColumnIndex = -1;\n  const columns: Array<Column<R> & { width: number | void }> = [];\n\n  for (const metricsColumn of metrics.columns) {\n    const width = getSpecifiedWidth(metricsColumn, metrics.columnWidths, metrics.viewportWidth, metrics.minColumnWidth);\n    const column = { ...metricsColumn, width };\n\n    if (width === undefined) {\n      unassignedColumnsCount++;\n    } else {\n      allocatedWidths += width;\n    }\n\n    if (isFrozen(column)) {\n      lastFrozenColumnIndex++;\n      columns.splice(lastFrozenColumnIndex, 0, column);\n    } else {\n      columns.push(column);\n    }\n  }\n\n  const unallocatedWidth = metrics.viewportWidth - allocatedWidths - getScrollbarSize();\n  const unallocatedColumnWidth = Math.max(\n    Math.floor(unallocatedWidth / unassignedColumnsCount),\n    metrics.minColumnWidth\n  );\n\n  const calculatedColumns: CalculatedColumn<R>[] = columns.map((column, idx) => {\n    // Every column should have a valid width as this stage\n    const width = column.width === undefined ? unallocatedColumnWidth : column.width;\n    const newColumn: CalculatedColumn<R> = {\n      ...column,\n      idx,\n      width,\n      left,\n      cellContentRenderer: column.cellContentRenderer || metrics.defaultCellContentRenderer\n    };\n    totalWidth += width;\n    left += width;\n    return newColumn;\n  });\n\n  return {\n    columns: calculatedColumns,\n    lastFrozenColumnIndex,\n    totalColumnWidth: totalWidth,\n    viewportWidth: metrics.viewportWidth\n  };\n}\n\nfunction getSpecifiedWidth<R>(\n  column: Column<R>,\n  columnWidths: Map<keyof R, number>,\n  viewportWidth: number,\n  minColumnWidth: number\n): number | void {\n  if (columnWidths.has(column.key)) {\n    // Use the resized width if available\n    return columnWidths.get(column.key);\n  }\n  if (typeof column.width === 'number') {\n    // TODO: allow width to be less than minWidth?\n    return Math.max(column.width, minColumnWidth);\n  }\n  if (typeof column.width === 'string' && /^\\d+%$/.test(column.width)) {\n    return Math.max(Math.floor(viewportWidth * parseInt(column.width, 10) / 100), minColumnWidth);\n  }\n}\n\n// Logic extented to allow for functions to be passed down in column.editable\n// this allows us to deicde whether we can be editing from a cell level\nexport function canEdit<R>(column: CalculatedColumn<R>, rowData: R, enableCellSelect?: boolean): boolean {\n  if (typeof column.editable === 'function') {\n    return enableCellSelect === true && column.editable(rowData);\n  }\n  return enableCellSelect === true && (!!column.editor || !!column.editable);\n}\n\nexport function isFrozen<R>(column: Column<R> | CalculatedColumn<R>): boolean {\n  return column.frozen === true;\n}\n\nexport function getColumnScrollPosition<R>(columns: CalculatedColumn<R>[], idx: number, currentScrollLeft: number, currentClientWidth: number): number {\n  let left = 0;\n  let frozen = 0;\n\n  for (let i = 0; i < idx; i++) {\n    const column = columns[i];\n    if (column) {\n      if (column.width) {\n        left += column.width;\n      }\n      if (isFrozen(column)) {\n        frozen += column.width;\n      }\n    }\n  }\n\n  const selectedColumn = columns[idx];\n  if (selectedColumn) {\n    const scrollLeft = left - frozen - currentScrollLeft;\n    const scrollRight = left + selectedColumn.width - currentScrollLeft;\n\n    if (scrollLeft < 0) {\n      return scrollLeft;\n    }\n    if (scrollRight > currentClientWidth) {\n      return scrollRight - currentClientWidth;\n    }\n  }\n\n  return 0;\n}\n"]}