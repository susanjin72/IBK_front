{"version":3,"file":"viewportUtils.js","sourceRoot":"","sources":["../../src/utils/viewportUtils.ts"],"names":[],"mappings":"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","sourcesContent":["import { CalculatedColumn, ColumnMetrics } from '../common/types';\n\nfunction getTotalFrozenColumnWidth<R>(columns: CalculatedColumn<R>[], lastFrozenColumnIndex: number): number {\n  if (lastFrozenColumnIndex === -1) {\n    return 0;\n  }\n  const lastFrozenColumn = columns[lastFrozenColumnIndex];\n  return lastFrozenColumn.left + lastFrozenColumn.width;\n}\n\nexport function getVerticalRangeToRender(\n  height: number,\n  rowHeight: number,\n  scrollTop: number,\n  rowsCount: number,\n  renderBatchSize: number\n) {\n  const overscanThreshold = 4;\n  const rowVisibleStartIdx = Math.floor(scrollTop / rowHeight);\n  const rowVisibleEndIdx = Math.min(rowsCount - 1, Math.floor((scrollTop + height) / rowHeight));\n  const rowOverscanStartIdx = Math.max(0, Math.floor((rowVisibleStartIdx - overscanThreshold) / renderBatchSize) * renderBatchSize);\n  const rowOverscanEndIdx = Math.min(rowsCount - 1, Math.ceil((rowVisibleEndIdx + overscanThreshold) / renderBatchSize) * renderBatchSize);\n\n  return [rowOverscanStartIdx, rowOverscanEndIdx] as const;\n}\n\nexport interface HorizontalRangeToRender {\n  colVisibleStartIdx: number;\n  colVisibleEndIdx: number;\n  colOverscanStartIdx: number;\n  colOverscanEndIdx: number;\n}\n\nexport interface HorizontalRangeToRenderParams<R> {\n  columnMetrics: ColumnMetrics<R>;\n  scrollLeft: number;\n}\n\nexport function getHorizontalRangeToRender<R>({\n  columnMetrics,\n  scrollLeft\n}: HorizontalRangeToRenderParams<R>): HorizontalRangeToRender {\n  const { columns, lastFrozenColumnIndex, viewportWidth } = columnMetrics;\n  // get the viewport's left side and right side positions for non-frozen columns\n  const totalFrozenColumnWidth = getTotalFrozenColumnWidth(columns, lastFrozenColumnIndex);\n  const viewportLeft = scrollLeft + totalFrozenColumnWidth;\n  const viewportRight = scrollLeft + viewportWidth;\n  // get first and last non-frozen column indexes\n  const lastColIdx = columns.length - 1;\n  const firstUnfrozenColumnIdx = Math.min(lastFrozenColumnIndex + 1, lastColIdx);\n\n  // skip rendering non-frozen columns if the frozen columns cover the entire viewport\n  if (viewportLeft >= viewportRight) {\n    return {\n      colVisibleStartIdx: firstUnfrozenColumnIdx,\n      colVisibleEndIdx: firstUnfrozenColumnIdx,\n      colOverscanStartIdx: firstUnfrozenColumnIdx,\n      colOverscanEndIdx: firstUnfrozenColumnIdx\n    };\n  }\n\n  // get the first visible non-frozen column index\n  let colVisibleStartIdx = firstUnfrozenColumnIdx;\n  while (colVisibleStartIdx < lastColIdx) {\n    const { left, width } = columns[colVisibleStartIdx];\n    // if the right side of the columnn is beyond the left side of the available viewport,\n    // then it is the first column that's at least partially visible\n    if (left + width > viewportLeft) {\n      break;\n    }\n    colVisibleStartIdx++;\n  }\n\n  // get the last visible non-frozen column index\n  let colVisibleEndIdx = colVisibleStartIdx;\n  while (colVisibleEndIdx < lastColIdx) {\n    const { left, width } = columns[colVisibleEndIdx];\n    // if the right side of the column is beyond or equal to the right side of the available viewport,\n    // then it the last column that's at least partially visible, as the previous column's right side is not beyond the viewport.\n    if (left + width >= viewportRight) {\n      break;\n    }\n    colVisibleEndIdx++;\n  }\n\n  const colOverscanStartIdx = Math.max(firstUnfrozenColumnIdx, colVisibleStartIdx - 1);\n  const colOverscanEndIdx = Math.min(lastColIdx, colVisibleEndIdx + 1);\n\n  return { colVisibleStartIdx, colVisibleEndIdx, colOverscanStartIdx, colOverscanEndIdx };\n}\n"]}